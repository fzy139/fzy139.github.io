#### 模拟问题

* 设计数据模型--考虑边界的设计（-1？）

#### 枚举
* 本质是 把问题用一定数据结构描述，然后遍历
* 构建搜索树 
* 慢的原因是DFS 结果产生在叶节点 大
* 普遍但低效
* 通过枚举去反应问题的内在机制

```
Zero Sum
```

#### 贪心
只选择局部最优，只考虑当前的最优选择，不考虑对后面的影响

如果整体最优解可通过局部最优得到，可以使用贪心

#### 求解过程 
先进行排序

枚举+贪心

枚举用来去除干扰因素（影响后续选择的决策）
不影响的用贪心来解决。
用其他方法来刨除干扰项。

```
灯泡问题

```




```

打字员安排问题`
```
枚举划分 t>= max(ti)
二分法枚举时间，贪心检测是否找出贪心解（）







# DFS
贪心算法效率更高，减去所有 \
1.不断构建一个解决方案（增加深度），逻辑比较顺畅\
2.深度确定\
\
**剪枝是优化主要手段** \
走到分支的尽头，不满足就回溯 \
设置一个标志存储分支，存储量比广度优先小。

BFS是把待搜索节点放到队列，一次\
\
使用递归编程\
对应栈

**优化**\
重复计算判定 使用结果集(备忘录法)

```
四皇后问题 
Sum it up
```

每个数取与不取 作差计算距离
* 相同数的处理,在处理右子数时加入相同判断，传入上一个数，判断是否
* 也可以写两个函数 处理左子树和右子树

```
genetic code
```
后面判断过的前面不用判断了 只用判断加入后

**如何选择？**\
1.看是否要求结果不能重复\
DFS不好处理 重复判断\
* 只要找到答案 用DFS（更快）
* 找最短路径 (对比所有结果 ) BFS
  
2.深度确定 \
或者使用迭代加深 即某曾没有答案时继续加深度\

3.规模小时
DFS需要很多剪枝才能优化 但是往往剪枝比较难(处理过的减掉 但是不好发现)\





* BFS 通过状态存储来优化，可通过状态压缩进行优化
* DFS 只记录当前路径


